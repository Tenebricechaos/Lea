"""
Système d'Auto-Pentest pour Léa
Effectue des tests d'intrusion automatisés et continus sur le code généré
et les applications déployées pour identifier et corriger proactivement les vulnérabilités.
"""

import re
import ast
import subprocess
import tempfile
import os
import json
import time
import hashlib
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed

from src.models.ast_universal import UniversalSyntaxTree, NodeType

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class VulnerabilityType(Enum):
    """Types de vulnérabilités détectées"""
    SQL_INJECTION = "sql_injection"
    XSS = "cross_site_scripting"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    WEAK_CRYPTO = "weak_cryptography"
    HARDCODED_SECRETS = "hardcoded_secrets"
    UNSAFE_EVAL = "unsafe_eval"
    BUFFER_OVERFLOW = "buffer_overflow"
    RACE_CONDITION = "race_condition"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DENIAL_OF_SERVICE = "denial_of_service"


class SeverityLevel(Enum):
    """Niveaux de sévérité des vulnérabilités"""
    INFO = 1
    LOW = 2
    MEDIUM = 3
    HIGH = 4
    CRITICAL = 5


@dataclass
class Vulnerability:
    """Représente une vulnérabilité détectée"""
    id: str
    type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    code_snippet: Optional[str] = None
    recommendation: Optional[str] = None
    cwe_id: Optional[str] = None  # Common Weakness Enumeration ID
    cvss_score: Optional[float] = None
    detected_at: float = field(default_factory=time.time)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convertit la vulnérabilité en dictionnaire"""
        return {
            'id': self.id,
            'type': self.type.value,
            'severity': self.severity.name,
            'title': self.title,
            'description': self.description,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'code_snippet': self.code_snippet,
            'recommendation': self.recommendation,
            'cwe_id': self.cwe_id,
            'cvss_score': self.cvss_score,
            'detected_at': self.detected_at
        }


@dataclass
class PentestReport:
    """Rapport de test d'intrusion"""
    scan_id: str
    target: str
    start_time: float
    end_time: Optional[float] = None
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    scan_type: str = "auto_pentest"
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def add_vulnerability(self, vulnerability: Vulnerability):
        """Ajoute une vulnérabilité au rapport"""
        self.vulnerabilities.append(vulnerability)
    
    def get_severity_counts(self) -> Dict[str, int]:
        """Retourne le nombre de vulnérabilités par niveau de sévérité"""
        counts = {level.name: 0 for level in SeverityLevel}
        for vuln in self.vulnerabilities:
            counts[vuln.severity.name] += 1
        return counts
    
    def get_critical_vulnerabilities(self) -> List[Vulnerability]:
        """Retourne les vulnérabilités critiques"""
        return [v for v in self.vulnerabilities if v.severity == SeverityLevel.CRITICAL]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convertit le rapport en dictionnaire"""
        return {
            'scan_id': self.scan_id,
            'target': self.target,
            'start_time': self.start_time,
            'end_time': self.end_time,
            'scan_type': self.scan_type,
            'metadata': self.metadata,
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            'severity_counts': self.get_severity_counts(),
            'total_vulnerabilities': len(self.vulnerabilities)
        }


class StaticAnalyzer:
    """Analyseur statique pour la détection de vulnérabilités"""
    
    def __init__(self):
        self.vulnerability_patterns = self._init_vulnerability_patterns()
    
    def _init_vulnerability_patterns(self) -> Dict[VulnerabilityType, List[Dict[str, Any]]]:
        """Initialise les patterns de détection de vulnérabilités"""
        return {
            VulnerabilityType.SQL_INJECTION: [
                {
                    'pattern': r'(SELECT|INSERT|UPDATE|DELETE).*\+.*',
                    'description': 'Possible SQL injection via string concatenation',
                    'severity': SeverityLevel.HIGH,
                    'cwe_id': 'CWE-89'
                },
                {
                    'pattern': r'execute\s*\(\s*["\'].*%.*["\']',
                    'description': 'SQL query with string formatting',
                    'severity': SeverityLevel.MEDIUM,
                    'cwe_id': 'CWE-89'
                }
            ],
            VulnerabilityType.XSS: [
                {
                    'pattern': r'innerHTML\s*=.*\+',
                    'description': 'Possible XSS via innerHTML manipulation',
                    'severity': SeverityLevel.MEDIUM,
                    'cwe_id': 'CWE-79'
                },
                {
                    'pattern': r'document\.write\s*\(',
                    'description': 'Use of document.write can lead to XSS',
                    'severity': SeverityLevel.MEDIUM,
                    'cwe_id': 'CWE-79'
                }
            ],
            VulnerabilityType.COMMAND_INJECTION: [
                {
                    'pattern': r'(system|exec|popen|subprocess\.call)\s*\(.*\+',
                    'description': 'Command injection via string concatenation',
                    'severity': SeverityLevel.CRITICAL,
                    'cwe_id': 'CWE-78'
                },
                {
                    'pattern': r'os\.system\s*\(',
                    'description': 'Use of os.system can be dangerous',
                    'severity': SeverityLevel.HIGH,
                    'cwe_id': 'CWE-78'
                }
            ],
            VulnerabilityType.PATH_TRAVERSAL: [
                {
                    'pattern': r'open\s*\(.*\+.*\.\.',
                    'description': 'Possible path traversal in file operations',
                    'severity': SeverityLevel.HIGH,
                    'cwe_id': 'CWE-22'
                }
            ],
            VulnerabilityType.HARDCODED_SECRETS: [
                {
                    'pattern': r'(password|secret|key|token)\s*=\s*["\'][^"\']{8,}["\']',
                    'description': 'Hardcoded secret detected',
                    'severity': SeverityLevel.HIGH,
                    'cwe_id': 'CWE-798'
                },
                {
                    'pattern': r'(api_key|access_token)\s*=\s*["\'][A-Za-z0-9]{20,}["\']',
                    'description': 'Hardcoded API key detected',
                    'severity': SeverityLevel.CRITICAL,
                    'cwe_id': 'CWE-798'
                }
            ],
            VulnerabilityType.UNSAFE_EVAL: [
                {
                    'pattern': r'eval\s*\(',
                    'description': 'Use of eval() can be dangerous',
                    'severity': SeverityLevel.HIGH,
                    'cwe_id': 'CWE-95'
                },
                {
                    'pattern': r'exec\s*\(',
                    'description': 'Use of exec() can be dangerous',
                    'severity': SeverityLevel.HIGH,
                    'cwe_id': 'CWE-95'
                }
            ],
            VulnerabilityType.WEAK_CRYPTO: [
                {
                    'pattern': r'(md5|sha1)\s*\(',
                    'description': 'Weak cryptographic hash function',
                    'severity': SeverityLevel.MEDIUM,
                    'cwe_id': 'CWE-327'
                },
                {
                    'pattern': r'DES|RC4',
                    'description': 'Weak encryption algorithm',
                    'severity': SeverityLevel.HIGH,
                    'cwe_id': 'CWE-327'
                }
            ]
        }
    
    def analyze_code(self, source_code: str, file_path: Optional[str] = None) -> List[Vulnerability]:
        """Analyse le code source pour détecter les vulnérabilités"""
        vulnerabilities = []
        lines = source_code.split('\n')
        
        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info['pattern']
                
                for line_num, line in enumerate(lines, 1):
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    
                    for match in matches:
                        vuln_id = hashlib.md5(
                            f"{file_path}:{line_num}:{pattern}".encode()
                        ).hexdigest()[:8]
                        
                        vulnerability = Vulnerability(
                            id=vuln_id,
                            type=vuln_type,
                            severity=pattern_info['severity'],
                            title=f"{vuln_type.value.replace('_', ' ').title()} Detected",
                            description=pattern_info['description'],
                            file_path=file_path,
                            line_number=line_num,
                            code_snippet=line.strip(),
                            recommendation=self._get_recommendation(vuln_type),
                            cwe_id=pattern_info.get('cwe_id')
                        )
                        
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def analyze_ast(self, ust: UniversalSyntaxTree) -> List[Vulnerability]:
        """Analyse l'ASU pour détecter les vulnérabilités structurelles"""
        vulnerabilities = []
        
        # Analyse des appels de fonction dangereux
        call_nodes = ust.get_nodes_by_type(NodeType.CALL_EXPRESSION)
        for call_node in call_nodes:
            func_name = call_node.get_attribute('function_name', '')
            
            if func_name in ['eval', 'exec', 'system']:
                vuln_id = hashlib.md5(f"ast:{call_node.id}:{func_name}".encode()).hexdigest()[:8]
                
                vulnerability = Vulnerability(
                    id=vuln_id,
                    type=VulnerabilityType.UNSAFE_EVAL if func_name in ['eval', 'exec'] else VulnerabilityType.COMMAND_INJECTION,
                    severity=SeverityLevel.HIGH,
                    title=f"Dangerous Function Call: {func_name}",
                    description=f"Use of {func_name}() detected in AST analysis",
                    line_number=call_node.source_range.start.line if call_node.source_range else None,
                    recommendation=self._get_recommendation(VulnerabilityType.UNSAFE_EVAL)
                )
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _get_recommendation(self, vuln_type: VulnerabilityType) -> str:
        """Retourne une recommandation pour corriger la vulnérabilité"""
        recommendations = {
            VulnerabilityType.SQL_INJECTION: "Use parameterized queries or prepared statements instead of string concatenation.",
            VulnerabilityType.XSS: "Sanitize user input and use safe DOM manipulation methods.",
            VulnerabilityType.COMMAND_INJECTION: "Use safe subprocess methods with proper input validation.",
            VulnerabilityType.PATH_TRAVERSAL: "Validate and sanitize file paths, use absolute paths when possible.",
            VulnerabilityType.HARDCODED_SECRETS: "Store secrets in environment variables or secure configuration files.",
            VulnerabilityType.UNSAFE_EVAL: "Avoid using eval() and exec(). Use safer alternatives like JSON.parse() or ast.literal_eval().",
            VulnerabilityType.WEAK_CRYPTO: "Use strong cryptographic algorithms like SHA-256, SHA-3, or bcrypt."
        }
        
        return recommendations.get(vuln_type, "Review the code and apply security best practices.")


class DynamicAnalyzer:
    """Analyseur dynamique pour les tests d'intrusion en temps réel"""
    
    def __init__(self):
        self.test_payloads = self._init_test_payloads()
    
    def _init_test_payloads(self) -> Dict[VulnerabilityType, List[str]]:
        """Initialise les payloads de test pour différents types de vulnérabilités"""
        return {
            VulnerabilityType.SQL_INJECTION: [
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "' UNION SELECT * FROM users --",
                "1' AND 1=1 --"
            ],
            VulnerabilityType.XSS: [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "';alert('XSS');//"
            ],
            VulnerabilityType.COMMAND_INJECTION: [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd",
                "`id`"
            ],
            VulnerabilityType.PATH_TRAVERSAL: [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd"
            ]
        }
    
    def test_endpoint(self, url: str, method: str = 'GET', 
                     params: Optional[Dict[str, str]] = None) -> List[Vulnerability]:
        """Teste un endpoint pour les vulnérabilités"""
        vulnerabilities = []
        
        # Test des payloads d'injection
        for vuln_type, payloads in self.test_payloads.items():
            for payload in payloads:
                try:
                    # Simulation de test (dans un vrai système, ceci ferait des requêtes HTTP)
                    vulnerability = self._simulate_payload_test(url, payload, vuln_type)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        
                except Exception as e:
                    logger.error(f"Erreur lors du test de {url} avec payload {payload}: {e}")
        
        return vulnerabilities
    
    def _simulate_payload_test(self, url: str, payload: str, 
                              vuln_type: VulnerabilityType) -> Optional[Vulnerability]:
        """Simule un test de payload (à remplacer par de vrais tests HTTP)"""
        
        # Simulation : détection basée sur des patterns dans l'URL
        if vuln_type == VulnerabilityType.SQL_INJECTION and "sql" in url.lower():
            vuln_id = hashlib.md5(f"{url}:{payload}".encode()).hexdigest()[:8]
            
            return Vulnerability(
                id=vuln_id,
                type=vuln_type,
                severity=SeverityLevel.HIGH,
                title="SQL Injection Vulnerability",
                description=f"Endpoint {url} appears vulnerable to SQL injection",
                recommendation="Implement proper input validation and parameterized queries"
            )
        
        return None


class AutoPentestEngine:
    """Moteur principal d'auto-pentest"""
    
    def __init__(self):
        self.static_analyzer = StaticAnalyzer()
        self.dynamic_analyzer = DynamicAnalyzer()
        self.scan_history: Dict[str, PentestReport] = {}
        self.active_scans: Set[str] = set()
    
    def scan_code(self, source_code: str, file_path: Optional[str] = None,
                  language: Optional[str] = None) -> PentestReport:
        """Effectue un scan de sécurité complet sur du code source"""
        
        scan_id = hashlib.md5(f"{source_code}:{time.time()}".encode()).hexdigest()[:8]
        
        report = PentestReport(
            scan_id=scan_id,
            target=file_path or "inline_code",
            start_time=time.time(),
            metadata={
                'language': language,
                'code_length': len(source_code),
                'scan_type': 'static_analysis'
            }
        )
        
        self.active_scans.add(scan_id)
        
        try:
            # Analyse statique
            static_vulns = self.static_analyzer.analyze_code(source_code, file_path)
            for vuln in static_vulns:
                report.add_vulnerability(vuln)
            
            logger.info(f"Scan statique terminé pour {scan_id}: {len(static_vulns)} vulnérabilités trouvées")
            
        except Exception as e:
            logger.error(f"Erreur lors du scan statique {scan_id}: {e}")
        
        finally:
            report.end_time = time.time()
            self.active_scans.discard(scan_id)
            self.scan_history[scan_id] = report
        
        return report
    
    def scan_ast(self, ust: UniversalSyntaxTree) -> PentestReport:
        """Effectue un scan de sécurité sur un ASU"""
        
        scan_id = hashlib.md5(f"ast:{ust.root.id}:{time.time()}".encode()).hexdigest()[:8]
        
        report = PentestReport(
            scan_id=scan_id,
            target="universal_syntax_tree",
            start_time=time.time(),
            metadata={
                'language': ust.metadata.get('language'),
                'node_count': len(ust.root.children),
                'scan_type': 'ast_analysis'
            }
        )
        
        self.active_scans.add(scan_id)
        
        try:
            # Analyse de l'ASU
            ast_vulns = self.static_analyzer.analyze_ast(ust)
            for vuln in ast_vulns:
                report.add_vulnerability(vuln)
            
            logger.info(f"Scan ASU terminé pour {scan_id}: {len(ast_vulns)} vulnérabilités trouvées")
            
        except Exception as e:
            logger.error(f"Erreur lors du scan ASU {scan_id}: {e}")
        
        finally:
            report.end_time = time.time()
            self.active_scans.discard(scan_id)
            self.scan_history[scan_id] = report
        
        return report
    
    def scan_application(self, base_url: str, endpoints: List[str]) -> PentestReport:
        """Effectue un scan de sécurité dynamique sur une application"""
        
        scan_id = hashlib.md5(f"{base_url}:{time.time()}".encode()).hexdigest()[:8]
        
        report = PentestReport(
            scan_id=scan_id,
            target=base_url,
            start_time=time.time(),
            metadata={
                'endpoints': endpoints,
                'scan_type': 'dynamic_analysis'
            }
        )
        
        self.active_scans.add(scan_id)
        
        try:
            # Test dynamique des endpoints
            with ThreadPoolExecutor(max_workers=5) as executor:
                futures = []
                
                for endpoint in endpoints:
                    url = f"{base_url.rstrip('/')}/{endpoint.lstrip('/')}"
                    future = executor.submit(self.dynamic_analyzer.test_endpoint, url)
                    futures.append(future)
                
                for future in as_completed(futures):
                    try:
                        vulns = future.result()
                        for vuln in vulns:
                            report.add_vulnerability(vuln)
                    except Exception as e:
                        logger.error(f"Erreur lors du test d'endpoint: {e}")
            
            logger.info(f"Scan dynamique terminé pour {scan_id}: {len(report.vulnerabilities)} vulnérabilités trouvées")
            
        except Exception as e:
            logger.error(f"Erreur lors du scan dynamique {scan_id}: {e}")
        
        finally:
            report.end_time = time.time()
            self.active_scans.discard(scan_id)
            self.scan_history[scan_id] = report
        
        return report
    
    def get_scan_report(self, scan_id: str) -> Optional[PentestReport]:
        """Récupère un rapport de scan"""
        return self.scan_history.get(scan_id)
    
    def get_active_scans(self) -> List[str]:
        """Retourne la liste des scans actifs"""
        return list(self.active_scans)
    
    def generate_remediation_plan(self, report: PentestReport) -> Dict[str, Any]:
        """Génère un plan de remédiation basé sur le rapport"""
        
        critical_vulns = report.get_critical_vulnerabilities()
        severity_counts = report.get_severity_counts()
        
        # Priorisation des vulnérabilités
        priority_order = [
            SeverityLevel.CRITICAL,
            SeverityLevel.HIGH,
            SeverityLevel.MEDIUM,
            SeverityLevel.LOW,
            SeverityLevel.INFO
        ]
        
        remediation_tasks = []
        
        for severity in priority_order:
            vulns = [v for v in report.vulnerabilities if v.severity == severity]
            if vulns:
                for vuln in vulns:
                    task = {
                        'vulnerability_id': vuln.id,
                        'priority': severity.name,
                        'title': vuln.title,
                        'description': vuln.description,
                        'recommendation': vuln.recommendation,
                        'estimated_effort': self._estimate_effort(vuln),
                        'risk_level': severity.name
                    }
                    remediation_tasks.append(task)
        
        return {
            'scan_id': report.scan_id,
            'total_vulnerabilities': len(report.vulnerabilities),
            'severity_breakdown': severity_counts,
            'critical_count': len(critical_vulns),
            'remediation_tasks': remediation_tasks,
            'estimated_total_effort': sum(task['estimated_effort'] for task in remediation_tasks),
            'recommendations': self._get_general_recommendations(report)
        }
    
    def _estimate_effort(self, vulnerability: Vulnerability) -> int:
        """Estime l'effort de remédiation en heures"""
        effort_map = {
            SeverityLevel.CRITICAL: 8,
            SeverityLevel.HIGH: 4,
            SeverityLevel.MEDIUM: 2,
            SeverityLevel.LOW: 1,
            SeverityLevel.INFO: 0.5
        }
        
        return effort_map.get(vulnerability.severity, 2)
    
    def _get_general_recommendations(self, report: PentestReport) -> List[str]:
        """Génère des recommandations générales basées sur le rapport"""
        recommendations = []
        
        vuln_types = set(v.type for v in report.vulnerabilities)
        
        if VulnerabilityType.SQL_INJECTION in vuln_types:
            recommendations.append("Implement a comprehensive input validation framework")
        
        if VulnerabilityType.XSS in vuln_types:
            recommendations.append("Deploy Content Security Policy (CSP) headers")
        
        if VulnerabilityType.HARDCODED_SECRETS in vuln_types:
            recommendations.append("Implement a secrets management system")
        
        if len(report.vulnerabilities) > 10:
            recommendations.append("Consider implementing automated security testing in CI/CD pipeline")
        
        return recommendations


# Instance globale du moteur d'auto-pentest
auto_pentest_engine = AutoPentestEngine()

